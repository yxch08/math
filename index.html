<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>함수 시각화 프로그램</title>
	<style>
		body {
			font-family: 'Segoe UI', Arial, sans-serif;
			background: #f7f7f7;
			margin: 0;
			padding: 0;
			display: flex;
			flex-direction: column;
			min-height: 100vh;
		}
		.container {
			display: flex;
			flex: 1;
			padding: 24px 64px 24px 24px;
			gap: 24px;
			box-sizing: border-box;
			height: 100vh;
		}
		.left-panel {
			flex: 2;
			display: flex;
			flex-direction: column;
			align-items: center;
			background: #fff;
			border-radius: 16px;
			box-shadow: 0 2px 8px #0001;
			padding: 16px;
			min-width: 0;
			position: relative;
		}
		.right-panel {
			flex: none;
			width: 270px;
			background: #fff;
			border-radius: 16px;
			box-shadow: 0 2px 8px #0001;
			padding: 16px;
			min-width: 220px;
			display: flex;
			flex-direction: column;
			gap: 12px;
			margin-left: 32px;
		}
		#graph-canvas {
			background: #fafbfc;
			border: 1px solid #ddd;
			border-radius: 8px;
			width: 900px;
			height: 700px;
			cursor: grab;
			margin-bottom: 16px;
			touch-action: none;
			display: block;
		}
		/* 하단 고정 함수 입력창 (챗봇 스타일) */
		#bottom-input-box {
			position: fixed;
			left: 0;
			bottom: 0;
			width: 100vw;
			background: #f4f6fb;
			box-shadow: 0 -2px 16px #0001;
			padding: 18px 0 14px 0;
			display: flex;
			flex-direction: row;
			align-items: center;
			gap: 12px;
			z-index: 200;
			border-top: 1.5px solid #e3e7f0;
		}
		#bottom-input-inner {
			margin: 0 auto;
			display: flex;
			flex-direction: row;
			align-items: center;
			gap: 10px;
			width: 100%;
			max-width: 900px;
		}
		.func-input {
			font-size: 1.1em;
			padding: 10px 16px;
			border: 1.5px solid #c3cbe7;
			border-radius: 24px;
			width: 340px;
			background: #fff;
			transition: border 0.2s;
			box-shadow: 0 1px 4px #0001;
		}
		.func-input:focus {
			border: 1.5px solid #0078d7;
			outline: none;
		}
		.func-btns {
			display: flex;
			gap: 4px;
		}
		.func-btns button {
			font-size: 1em;
			padding: 7px 14px;
			border: none;
			background: #e3e7fa;
			color: #2d3a5a;
			border-radius: 18px;
			cursor: pointer;
			transition: background 0.2s, box-shadow 0.2s;
			box-shadow: 0 1px 2px #0001;
		}
		.func-btns button:hover {
			background: #b6c6f5;
		}
		.action-btns {
			display: flex;
			gap: 8px;
		}
		.action-btns button {
			font-size: 1em;
			padding: 8px 24px;
			border: none;
			background: linear-gradient(90deg,#0078d7 60%,#43aa8b 100%);
			color: #fff;
			border-radius: 22px;
			cursor: pointer;
			transition: background 0.2s, box-shadow 0.2s;
			box-shadow: 0 1px 4px #0001;
			font-weight: 500;
		}
		.action-btns button:hover {
			background: linear-gradient(90deg,#005fa3 60%,#2e8b6a 100%);
		}
		/* 함수 목록 창 디자인 복원 */
		.func-list {
			flex: 1;
			overflow-y: auto;
			margin-top: 8px;
		}
		.func-item {
			background: #f3f6fa;
			border-radius: 6px;
			padding: 8px 10px;
			margin-bottom: 6px;
			display: flex;
			align-items: center;
			justify-content: space-between;
			font-size: 1.08em;
			word-break: break-all;
		}
		.func-color {
			width: 16px;
			height: 16px;
			border-radius: 50%;
			margin-right: 8px;
			display: inline-block;
			border: 1.5px solid #bbb;
		}
		.remove-btn {
			background: #ffb3b3;
			color: #a00;
			border: none;
			border-radius: 4px;
			padding: 2px 8px;
			cursor: pointer;
			font-size: 0.95em;
			margin-left: 8px;
			transition: background 0.2s;
		}
		.remove-btn:hover {
			background: #ff6b6b;
		}
		.intersection-label {
			position: absolute;
			background: #fffbe7;
			border: 1px solid #e3c800;
			border-radius: 4px;
			padding: 2px 8px;
			font-size: 0.98em;
			pointer-events: none;
			z-index: 10;
			box-shadow: 0 1px 4px #0002;
		}
		@media (max-width: 1200px) {
			#graph-canvas {
				width: 98vw;
				height: 60vw;
				min-height: 220px;
			}
			#bottom-input-inner {
				max-width: 98vw;
			}
			.func-input {
				width: 160px;
			}
			.right-panel {
				margin-left: 0;
				width: 100vw;
			}
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="left-panel">
			<canvas id="graph-canvas" width="900" height="700"></canvas>
		</div>
		<div class="right-panel">
			<h3>함수 목록</h3>
			<div id="func-list" class="func-list"></div>
		</div>
	</div>
	<!-- 하단 고정 함수 입력창 (챗봇 스타일) -->
	<div id="bottom-input-box">
		<div id="bottom-input-inner">
			<input id="func-input" class="func-input" placeholder="함수를 입력하세요. 예: x^2+2x-3, sin(x), log(x)" />
			<div class="func-btns">
				<button type="button" onclick="insertFunc('sin')">sin</button>
				<button type="button" onclick="insertFunc('cos')">cos</button>
				<button type="button" onclick="insertFunc('tan')">tan</button>
				<button type="button" onclick="insertFunc('log')">log</button>
				<button type="button" onclick="insertFunc('exp')">exp</button>
				<button type="button" onclick="insertFunc('^')">^</button>
			</div>
			<div class="action-btns">
				<button type="button" onclick="addFunction()">추가</button>
				<button type="button" onclick="resetAll()">초기화</button>
				<button type="button" onclick="moveToOrigin()">원점</button>
			</div>
		</div>
	</div>
	<div id="intersection-label" class="intersection-label" style="display:none;"></div>
	<script>
		// 수식 파싱 및 평가를 위한 간단한 파서 (math.js 없이 구현)
		// 실제 서비스에서는 math.js 등 라이브러리 사용 권장
		function parseExpr(expr) {
			// 안전하게 변환: ^ -> **, sin/cos/tan/log/exp -> Math.함수
			let safe = expr.replace(/\^/g, '**')
				.replace(/([a-zA-Z]+)\(/g, function(_, fn) {
					if(['sin','cos','tan','log','exp'].includes(fn)) return 'Math.'+fn+'('; 
					return fn+'('; 
				})
				.replace(/log\(/g, 'Math.log10(')
				.replace(/([0-9])([a-zA-Z])/g, '$1*$2') // 2x -> 2*x
				.replace(/([a-zA-Z])([0-9])/g, '$1*$2'); // x2 -> x*2
			return safe;
		}
		function makeFunc(expr) {
			const parsed = parseExpr(expr);
			try {
				// eslint-disable-next-line no-new-func
				return new Function('x', 'return ' + parsed + ';');
			} catch {
				return null;
			}
		}
		// 색상 팔레트
		const COLORS = [
			'#0078d7', '#e4572e', '#17bebb', '#ffc914', '#6a4c93', '#2e282a', '#ff6b6b', '#43aa8b', '#f37736', '#005fa3'
		];
		let functions = [];
		let intersections = [];
		let scale = 40; // 1단위 = 40px
		let offsetX = 0, offsetY = 0;
		let drag = false, lastX = 0, lastY = 0;
		let canvas, ctx;
		let width = 600, height = 480;
		let minScale = 10, maxScale = 1000;
		function draw() {
			canvas = document.getElementById('graph-canvas');
			ctx = canvas.getContext('2d');
			width = canvas.width;
			height = canvas.height;
			ctx.clearRect(0,0,width,height);
			const cx = width/2 + offsetX;
			const cy = height/2 + offsetY;
			ctx.save();
			ctx.strokeStyle = '#e0e0e0';
			ctx.lineWidth = 1;
			for(let x = cx%scale; x < width; x += scale) {
				ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke();
			}
			for(let y = cy%scale; y < height; y += scale) {
				ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(width,y); ctx.stroke();
			}
			ctx.restore();
			// x, y축 (검정색)
			ctx.save();
			ctx.strokeStyle = '#222';
			ctx.lineWidth = 3.2;
			ctx.beginPath(); ctx.moveTo(0,cy); ctx.lineTo(width,cy); ctx.stroke();
			ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,height); ctx.stroke();
			// 원점 표시
			ctx.beginPath();
			ctx.arc(cx, cy, 7, 0, 2*Math.PI);
			ctx.fillStyle = '#ffc914';
			ctx.fill();
			ctx.strokeStyle = '#bba800';
			ctx.lineWidth = 2;
			ctx.stroke();
			ctx.restore();
			ctx.save();
			ctx.fillStyle = '#444';
			ctx.font = '12px sans-serif';
			for(let x = cx%scale; x < width; x += scale) {
				let val = ((x-cx)/scale).toFixed(1);
				if(Math.abs(val)<1e-8) continue;
				ctx.fillText(val, x+2, cy+14);
			}
			for(let y = cy%scale; y < height; y += scale) {
				let val = ((cy-y)/scale).toFixed(1);
				if(Math.abs(val)<1e-8) continue;
				ctx.fillText(val, cx+4, y-4);
			}
			ctx.restore();
			// 함수 그래프
			functions.forEach((f, idx) => {
				ctx.save();
				ctx.strokeStyle = f.color;
				ctx.lineWidth = 2.2;
				ctx.beginPath();
				let first = true;
				let lastY = null;
				for(let px=0; px<=width; px+=1) {
					let x = (px-cx)/scale;
					let y;
					try { y = f.fn(x); } catch { y = NaN; }
					if(!isFinite(y)) { first=true; lastY=null; continue; }
					let py = cy - y*scale;
					if(first || lastY === null || Math.abs(py - lastY) > 100) { // 점근선 방지: y값이 급격히 튀면 선을 끊음
						ctx.moveTo(px, py); first=false;
					} else {
						ctx.lineTo(px, py);
					}
					lastY = py;
				}
				ctx.stroke();
				ctx.restore();
			});
			// 교점
			intersections.forEach(pt => {
				ctx.save();
				ctx.beginPath();
				ctx.arc(pt.px, pt.py, 6, 0, 2*Math.PI);
				ctx.fillStyle = '#2196f3'; // 교점 점 색깔을 파란색으로 변경
				ctx.fill();
				ctx.strokeStyle = '#1769aa'; // 테두리도 파란색 계열로 변경
				ctx.lineWidth = 2;
				ctx.stroke();
				ctx.restore();
			});
		}
		function updateFuncList() {
			const list = document.getElementById('func-list');
			list.innerHTML = '';
			functions.forEach((f, idx) => {
				const div = document.createElement('div');
				div.className = 'func-item';
				div.innerHTML = `<span><span class="func-color" style="background:${f.color}"></span>${f.expr}</span>` +
					`<button class="remove-btn" onclick="removeFunction(${idx})">삭제</button>`;
				list.appendChild(div);
			});
		}
		function addFunction() {
			const input = document.getElementById('func-input');
			const expr = input.value.trim();
			if(!expr) return;
			const fn = makeFunc(expr);
			if(!fn) { alert('함수 해석 오류!'); return; }
			const color = COLORS[functions.length%COLORS.length];
			functions.push({expr, fn, color});
			input.value = '';
			updateFuncList();
			findIntersections();
			draw();
		}
		function removeFunction(idx) {
			functions.splice(idx,1);
			updateFuncList();
			findIntersections();
			draw();
		}
		function resetAll() {
			functions = [];
			intersections = [];
			updateFuncList();
			draw();
		}
		function insertFunc(type) {
			const input = document.getElementById('func-input');
			let val = input.value;
			let insert = '';
			if(type==='^') insert = '^';
			else if(type==='log') insert = 'log()';
			else if(type==='exp') insert = 'exp()';
			else insert = type+'()';
			const pos = input.selectionStart || val.length;
			input.value = val.slice(0,pos) + insert + val.slice(pos);
			input.focus();
			// 괄호 안 x 자동 선택
			if(insert.endsWith('()')) {
				input.setSelectionRange(pos+insert.length-1, pos+insert.length-1);
			}
		}
		// 교점 찾기 (이분법으로 정확하게)
		function findIntersections() {
			intersections = [];
			if(functions.length<2) return;
			canvas = document.getElementById('graph-canvas');
			width = canvas.width;
			height = canvas.height;
			const cx = width/2 + offsetX;
			const cy = height/2 + offsetY;
			const xMin = -(cx)/scale;
			const xMax = (width-cx)/scale;
			const step = (xMax-xMin)/width * 4; // 4픽셀 단위로 샘플링
			for(let i=0; i<functions.length-1; ++i) {
				for(let j=i+1; j<functions.length; ++j) {
					let f1 = functions[i].fn, f2 = functions[j].fn;
					let prevX = xMin, prevDiff = null;
					for(let x=xMin; x<=xMax; x+=step) {
						let y1, y2;
						try { y1 = f1(x); y2 = f2(x); } catch { continue; }
						if(!isFinite(y1)||!isFinite(y2)) continue;
						let diff = y1-y2;
						if(prevDiff !== null && diff*prevDiff < 0) {
							// 근이 존재: 이분법으로 교점 근사
							let xLeft = prevX, xRight = x;
							let yLeft = f1(xLeft)-f2(xLeft), yRight = diff;
							let xRoot = null;
							for(let k=0;k<20;k++) { // 20회 반복으로 충분히 근사
								let xMid = (xLeft+xRight)/2;
								let yMid;
								try { yMid = f1(xMid)-f2(xMid); } catch { break; }
								if(!isFinite(yMid)) break;
								if(Math.abs(yMid)<1e-7) { xRoot = xMid; break; }
								if(yLeft*yMid<0) {
									xRight = xMid; yRight = yMid;
								} else {
									xLeft = xMid; yLeft = yMid;
								}
								xRoot = xMid;
							}
							if(xRoot !== null) {
								let yRoot;
								try { yRoot = f1(xRoot); } catch { yRoot = 0; }
								// 중복 교점 방지
								let isNear = intersections.some(pt => Math.abs(pt.x - xRoot) < 0.02 && Math.abs(pt.y - yRoot) < 0.02);
								if(!isNear) {
									let px = cx + xRoot*scale;
									let py = cy - yRoot*scale;
									intersections.push({x:xRoot, y:yRoot, px, py});
								}
							}
						}
						prevX = x;
						prevDiff = diff;
					}
				}
			}
		}
		// 교점 클릭 이벤트
		canvasClick = function(e) {
			const rect = canvas.getBoundingClientRect();
			const mx = e.clientX - rect.left;
			const my = e.clientY - rect.top;
			for(const pt of intersections) {
				if(Math.hypot(pt.px-mx, pt.py-my)<10) {
					showIntersectionLabel(pt, mx, my);
					return;
				}
			}
			document.getElementById('intersection-label').style.display = 'none';
		}
		function showIntersectionLabel(pt, mx, my) {
			const label = document.getElementById('intersection-label');
			label.textContent = `(${formatPi(pt.x)}, ${pt.y.toFixed(4)})`;
			label.style.left = (mx+20)+'px';
			label.style.top = (my-10)+'px';
			label.style.display = 'block';
		}
		// x값을 π로 표현하는 함수 추가
		function formatPi(x) {
			const pi = Math.PI;
			const epsilon = 0.01;
			let n = Math.round(x/pi);
			if(Math.abs(x - n*pi) < epsilon && n !== 0) {
				if(n === 1) return 'π';
				else if(n === -1) return '-π';
				else return n + 'π';
			}
			return x.toFixed(4);
		}
		// 확대/축소/드래그
		function setupCanvasEvents() {
			canvas.addEventListener('mousedown', e => {
				drag = true; lastX = e.clientX; lastY = e.clientY;
				canvas.style.cursor = 'grabbing';
			});
			window.addEventListener('mousemove', e => {
				if(!drag) return;
				offsetX += e.clientX - lastX;
				offsetY += e.clientY - lastY;
				lastX = e.clientX; lastY = e.clientY;
				findIntersections();
				draw();
			});
			window.addEventListener('mouseup', e => {
				drag = false;
				canvas.style.cursor = 'grab';
			});
			canvas.addEventListener('wheel', e => {
				if (!e.ctrlKey) return;
				e.preventDefault();
				let oldScale = scale;
				let newScale = scale;
				if(e.deltaY<0) {
					// 확대
					newScale = scale * 1.15;
				} else {
					// 축소
					newScale = scale / 1.15;
				}
				// 최소/최대 스케일 제한
				newScale = Math.max(minScale, Math.min(maxScale, newScale));
				// 축소 시에도 scale이 변하도록 수정
				if (Math.abs(newScale - scale) > 1e-2) {
					const rect = canvas.getBoundingClientRect();
					const mx = e.clientX - rect.left;
					const my = e.clientY - rect.top;
					const x = (mx-width/2-offsetX)/scale;
					const y = (height/2+offsetY-my)/scale;
					scale = newScale;
					offsetX += mx-width/2 - x*scale;
					offsetY += my-height/2 + y*scale;
					findIntersections();
					draw();
				}
			}, {passive:false});
			canvas.addEventListener('click', canvasClick);
			// 터치 지원
			let touchStart = null;
			canvas.addEventListener('touchstart', e => {
				if(e.touches.length==1) {
					drag = true;
					lastX = e.touches[0].clientX;
					lastY = e.touches[0].clientY;
				} else if(e.touches.length==2) {
					touchStart = e;
				}
			});
			canvas.addEventListener('touchmove', e => {
				if(drag && e.touches.length==1) {
					offsetX += e.touches[0].clientX - lastX;
					offsetY += e.touches[0].clientY - lastY;
					lastX = e.touches[0].clientX;
					lastY = e.touches[0].clientY;
					findIntersections();
					draw();
				} else if(e.touches.length==2 && touchStart) {
					// pinch zoom
					let d1 = Math.hypot(
						touchStart.touches[0].clientX-touchStart.touches[1].clientX,
						touchStart.touches[0].clientY-touchStart.touches[1].clientY
					);
					let d2 = Math.hypot(
						e.touches[0].clientX-e.touches[1].clientX,
						e.touches[0].clientY-e.touches[1].clientY
					);
					let factor = d2/d1;
					scale *= factor;
					scale = Math.max(minScale, Math.min(maxScale, scale));
					touchStart = e;
					findIntersections();
					draw();
				}
			});
			window.addEventListener('touchend', e => {
				drag = false;
				touchStart = null;
			});
		}
		window.onload = function() {
			canvas = document.getElementById('graph-canvas');
			ctx = canvas.getContext('2d');
			width = canvas.width;
			height = canvas.height;
			setupCanvasEvents();
			updateFuncList();
			findIntersections();
			draw();
		}
		// 엔터로 함수 추가
		document.addEventListener('DOMContentLoaded', function() {
			document.getElementById('func-input').addEventListener('keydown', function(e) {
				if(e.key==='Enter') addFunction();
			});
		});
		function moveToOrigin() {
			offsetX = 0;
			offsetY = 0;
			findIntersections();
			draw();
		}
	</script>
</html>
